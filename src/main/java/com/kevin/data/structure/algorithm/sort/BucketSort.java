package com.kevin.data.structure.algorithm.sort;

import com.alibaba.fastjson.JSON;

import java.util.Random;

/**
 *  桶排序
 *
 *  桶排序比较适合外部存储的情况， 即可能存在 10G的数据存放在磁盘中【无法一次加载到内存中】，
 *  并且数据需要排序的范围较小，而且最好是在排序字段分成的桶区间内数据尽量均匀
 *
 *
 *
 * @author kevin
 * @date 2021/2/22 15:19
 * @since 1.0.0
 */
public class BucketSort {

    public static void main(String[] args) {
        /*int[] array = new int[1000];
        Random random = new Random();
        for (int i = 0; i < array.length; i++) {
            array[i] = random.nextInt(100);
        }*/

        int[] array = new int[]{14,18,58,98,95,24,35,72,47,31,9,56,48,21,4,8,79,9,52,34,83,95,17,71,39,27,33,53,54,88,76,43,99,97,98,19,35,43,11,11,19,11,8,85,99,42,60,90,45,71,34,91,16,80,73,20,17,77,80,52,51,93,73,1,91,71,20,28,3,31,49,58,12,47,22,8,51,41,3,1,49,94,41,26,87,11,38,53,45,92,43,95,39,79,80,41,86,64,4,82,22,47,70,92,4,62,91,40,72,94,3,67,37,97,44,55,91,82,88,80,51,36,8,5,69,52,80,47,60,27,55,33,44,61,25,20,97,69,36,50,69,89,98,38,70,88,3,8,45,31,86,12,7,42,21,92,54,50,19,79,25,28,28,40,66,27,60,88,97,46,84,77,62,6,8,89,60,32,18,39,81,28,82,45,61,97,45,69,50,35,7,98,62,83,19,4,80,47,5,95,2,64,55,34,60,28,59,20,19,72,18,81,41,27,86,55,61,6,41,3,95,84,69,58,29,65,88,60,29,63,1,66,83,21,54,69,35,45,53,15,15,9,74,45,40,29,19,10,67,83,63,36,88,69,12,33,35,2,60,85,26,68,4,15,23,5,64,46,26,35,27,11,25,10,83,80,32,74,68,39,11,23,34,93,95,66,14,98,84,9,2,19,38,46,77,28,56,80,77,40,10,68,53,78,23,80,15,18,89,18,71,81,81,8,38,69,76,3,45,93,89,6,34,38,58,89,1,36,53,15,42,20,70,66,19,58,42,22,72,74,8,53,62,79,62,22,44,93,68,40,6,10,60,74,61,49,41,37,85,90,69,58,65,65,31,14,44,1,79,52,21,61,97,67,46,67,44,33,35,89,3,12,5,90,14,92,86,45,20,46,82,48,82,47,40,92,28,32,1,37,20,11,27,19,3,36,87,40,52,6,75,85,16,53,94,43,96,60,5,21,34,79,23,54,47,25,3,49,6,56,2,70,58,62,24,39,26,67,60,67,74,41,88,44,55,17,88,7,80,67,78,2,96,34,95,26,84,21,80,39,96,70,83,10,98,58,86,86,75,14,79,94,15,53,71,38,82,2,60,57,36,64,74,28,73,33,25,46,80,57,33,99,87,10,36,58,78,86,17,71,90,39,90,87,17,62,59,29,46,58,66,93,18,76,52,10,94,90,30,0,41,13,53,1,91,48,52,39,44,74,55,36,30,20,46,73,82,80,84,15,89,46,78,99,80,38,64,42,31,19,18,74,98,12,33,77,39,68,40,48,86,87,6,55,20,31,18,95,72,68,43,69,43,90,59,83,92,67,90,25,99,97,44,47,3,22,31,98,51,65,44,13,34,76,65,28,99,73,24,52,12,70,39,90,75,26,15,18,56,82,99,6,42,24,26,43,92,71,69,96,44,33,24,14,51,14,89,84,0,42,18,21,71,85,0,67,18,38,48,18,15,39,42,31,77,36,66,35,37,40,55,77,66,78,63,99,52,4,0,67,66,78,13,31,87,57,62,80,47,2,67,41,96,35,16,93,24,69,73,85,18,49,47,11,48,21,22,24,67,54,40,93,58,13,9,23,30,7,34,72,51,62,51,98,81,41,63,19,50,27,2,27,63,89,15,54,14,30,17,42,63,77,1,33,83,43,97,39,7,30,79,76,94,5,98,85,25,89,1,98,99,94,39,95,84,48,2,24,38,29,0,7,27,64,13,64,30,11,31,25,49,30,9,40,11,37,38,7,19,88,69,82,33,50,54,63,77,67,16,91,9,98,67,81,69,88,58,57,23,3,65,48,54,92,21,11,62,44,36,94,13,62,16,38,97,94,44,38,47,1,58,3,5,1,5,7,52,60,43,82,21,54,20,64,40,51,41,78,72,0,59,64,50,85,1,71,78,8,57,41,64,58,83,10,14,98,35,29,16,32,41,28,4,67,0,90,73,40,96,17,0,27,85,31,94,63,48,13,1,82,41,14,49,47,51,22,15,81,29,44,33,57,34,22,93,63,52,88,4,66,95,91,79,42,96,13,53,24,45,59,37,77,79,7,90,3,99,31,13,58,31,74,34,26,12,94,44,18,73,8,61,54,64,9,65,1,9,41,91,63,57,26,11,53,8,86,60,3,14,42,31,0,44,41,89,36,83,37,56,73,55,25,28,42,5,86,1,40,72,95,56,20,83,74,86,46,20,25,97,38,84,35,2,45,34,68,49,10,41,82,37,74,70,43,12,37,85,72,20,55,21,12,63,88,19,82,84,24,79,23};

        System.out.println("排序前：" + JSON.toJSONString(array));
        bucketSort(array, 10);
        System.out.println("排序后：" + JSON.toJSONString(array));
    }

    /**
     * 桶排序
     * 从代码的嵌套情况看， 没有 冒泡、选择、插入排序那样的 for for嵌套的情况，则不存在 O(N²) 的情况
     * 虽然使用了多次的单 for循环，但是整体趋势上是接近 O(N) 的时间复杂度
     *
     * @param array 待排序数据
     * @param bucketSize 桶容量
     */
    public static void bucketSort(int[] array, int bucketSize) {
        if (array.length < 2) {
            return;
        }

        // 记录需要排序的最大最小值
//        boolean isAsc = array[0] >= array[1];
//        int minValue = isAsc ? array[1] : array[0];
//        int maxValue = isAsc ? array[0] : array[1];

        // 数组最小值
        int minValue = array[0];
        // 数组最大值
        int maxValue = array[1];

        // 遍历一遍数据，确定数据的范围
        for (int i = 0; i < array.length; i++) {
            if (array[i] < minValue) {
                minValue = array[i];
            } else if (array[i] > maxValue) {
                maxValue = array[i];
            }
        }

        // 计算桶个数
        int bucketCount = (maxValue - minValue) / bucketSize + 1;
        int[][] buckets = new int[bucketCount][bucketSize];
        int[] indexArray = new int[bucketCount];

        // 将数值中的值分配到每个桶
        for (int i = 0; i < array.length; i++) {
            int bucketIndex = (array[i] - minValue) / bucketSize;
            if (indexArray[bucketIndex] == buckets[bucketIndex].length) {
                ensureCapacity(buckets, bucketIndex);
            }
            buckets[bucketIndex][indexArray[bucketIndex]++] = array[i];
        }

        // 对每个桶（二位数组）进行排序，这里使用快排
        int k = 0;
        for (int i = 0; i < buckets.length; i++) {
            // 可能存在桶没有数据的情况
            if (indexArray[i] == 0) {
                continue;
            }
            // 使用快排对当前的桶内元素进行排序
            QuickSort.quickSortInternally(buckets[i], 0, indexArray[i] - 1);
            for (int j = 0; j < indexArray[i]; j++) {
                array[k++] = buckets[i][j];
            }
        }
    }

    /**
     * 两倍进行扩容进行扩容
     * 当数据分布不均匀时，可能出现当前位置的桶的容量不够的情况，则进行两倍扩容
     *
     * @param buckets 桶数据
     * @param bucketIndex 当前桶的位置
     */
    private static void ensureCapacity(int[][] buckets, int bucketIndex) {
        int[] tmp = buckets[bucketIndex];
        // 申请新的两倍容量的数组
        int[] newArray = new int[tmp.length * 2];
        // 将原数据放到新数组的前面， 放完正好是容器的一半位置
        for (int i = 0; i < tmp.length; i++) {
            newArray[i] = tmp[i];
        }
        // 将桶数据替换为新数组
        buckets[bucketIndex] = newArray;
    }

}
